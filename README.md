
# Design Patterns
###### The purpose of this project is to document algorithms implementation, whose can be used as guide for the understanding of *design patterns*.

## Strategy

Strategy pattern defines a family of algorithms, incapsulating each one and makes them interchangeable. It lets the algorithm very independently from the clients that use it. 

## Observer

The Observer pattern defines an one to many dependency between objects, so that when an object changes its state all of its dependencies are notified and updated automatically.

## Decorator

The Decorator pattern attaches additional responsibilities to an object dynamically. It provides a flexible alternative to extend functionalities.

## Factory Method

The Factory Method defines an interface for creating an object, but lets the subclasses to decide which class to instantiate.

## Abstract Factory

The Abstract Factory pattern provides an inteface for creating families of related or dependent objects without specifing their concrete classes.

## Singleton

The Singleton pattern ensures that a class has only one instance and provides a global access to it.

## Command

The Command pattern encapsulates a request as an object thereby letting you parameterize other objects with different requests queue or log requests and support undoable operations.

## Adapter

The Adapter pattern converts the interface of a class into another interface that the client expect. It lets classes work together that could not otherwise because they are incompatible interfaces.

## Facade 

The Facade pattern provides an unified interface to a set of interfaces in a sub system. Facade defines a higher level interface that makes the sub system easier to use.

## Proxy

The Proxy pattern provides a surrogate or placeholder for another object in order to control access to it.

## Bridge

The intent of the Bridge pattern is to decouple an abstraction from its implementation so that the two can vary independently

## Template Method

The Template Method pattern defines the skeleton of an algorithm, deferring some steps to subclasses. It lets subclasses redefine certain steps of an algorithm without changing the algorithm structure.

## Composite

The Composite Pattern composes objects into tree structures and lets clients treat individual objects and compositions of objects uniformly. 

## Iterator

The Iterator Pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 

## State

The State Pattern allows an object to alter its behavior when its internal state changes.

## Builder

The Builder pattern allows you to create different types and representations of a complex object step by step. 

## Chain Of Responsibility

Chain of Responsibility pattern lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

## Flyweight

Flyweight design pattern lets you fit more objects by sharing common parts of state between multiple objects instead of keeping all of the data in each object.

## Interpreter

The Interpreter design pattern is used to define a grammatical representation for a language and provide an interpreter to deal with this grammar.

## Memento

The Memento pattern provides the ability to restore an object to its previous state.

## Visitor

The Visitor design pattern is a way of separating an algorithm from an object structure on which it operates, providing the ability to add new operations to existing object structures without modifying them.